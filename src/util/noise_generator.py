import numpy as np

"""
This file implements a complex stochastic process $z_t$ (colored noise) with the following properties:

- $\mathbb{E}\left[ z_t \right]=0,$
- $\mathbb{E}\left[ z_t z_s \right]=\mathbb{E}\left[ z_t^* z_s^* \right]=0$
- $\mathbb{E}\left[ z_t z_s^* \right]=\alpha(t-s)$

with the bath correlation function (BCF) \alpha(\tau).

Three implementations are given in this file:
1.) Implementation using a multivariate gaussian distribution
2.) Implementation using Fourier Filtering technique
3.) Implementation using a sum approximation of the BCF. This implementation
    can be used when using the alternative expansion of the BCF.

the second method is recommended as it is much faster. For each method there is a class that has to be initialized first
and can then be used to sample stochastic processes.
"""

class ColoredNoiseGenerator_Gaussian:
    """
    Class that generates a stochastic process with the given correlations 
    using a multivariate gaussian.
    
    Attributes
    ----------
    N_steps : int:
        length of the discrete stochastic process
    cov_matrix : np.ndarray
        covariance matrix that is used to generate the noise.
        is of shape (N_steps*2, N_steps*2)
        
    Methods
    -------
    sample_process()
        samples one realization of the stochastic process
    """
    
    def __init__(self, ts, alpha):
        """
        Parameters
        ----------
        ts : np.ndarray
            time values. Should be created using np.linspace(t_start, t_stop, N_steps)
        alpha: function
            should take a float $\tau$ as input and compute the desired bath correlation function
        """
        self.N_steps = ts.size
        self.cov_matrix = np.empty((self.N_steps*2, self.N_steps*2))
        for i in range(self.N_steps):
            for j in range(self.N_steps):
                corr = alpha(ts[i]-ts[j])
                xx_cov = 0.5*np.real(corr)
                self.cov_matrix[2*i, 2*j] = xx_cov
                self.cov_matrix[2*i+1, 2*j+1] = xx_cov
                xy_cov = -0.5*np.imag(corr)
                self.cov_matrix[2*i, 2*j+1] = xy_cov
                self.cov_matrix[2*i+1, 2*j] = -xy_cov
    
    """
    Generates a realization of a complex gaussian process

    Returns
    -------
    np.ndarray :
        array of length N containing the complex stochastic process
    """
    def sample_process(self):
        res = np.random.multivariate_normal(mean=np.zeros(self.N_steps*2), cov=self.cov_matrix)
        x, y = res[0::2], res[1::2]
        return x + 1j*y

def generate_white_noise(N):
    """
    Helper function that generates white complex noise

    Parameters
    ----------
    N : int
        length of the noise
    
    Returns
    -------
    np.ndarray :
        array of length N containing the complex white noise
    """ 
    return np.sqrt(-np.log(np.random.rand(N))) * np.exp(2.j*np.pi*np.random.rand(N))

class ColoredNoiseGenerator_FourierFiltering:
    """
    Class that generates a stochastic process with the given correlations
    using the Fourier Filtering technique as described in the book
    "Noise in spatially extended systems", on pages 95 (and following) and 
    272 (and following). 
    This is similar to the implementation used in the original HOPS paper
    
    Attributes
    ----------
    N_steps : int:
        length of the discrete stochastic process
    sqrtJ : np.ndarray 
        the square root of the fourier transformed correlation function.
        The noise is generated by folding white noise with sqrtJ.
        
    Methods
    -------
    sample_process()
        samples one realization of the stochastic process
    """
    
    def __init__(self, alpha, t_start, t_stop):
        """
        Initializes the generator by computing the values of the correlation function alpha
        at the discrete time steps and transforming it to frequency space
        ----------
        Parameters
        N_steps : int
            length of the noise
        alpha: function of float returning complex 
            correlation function
        t_start : float 
            starting time of the process
        t_stop : float 
            final time of the process
        """
        assert(t_start==0)
        self.alpha = alpha
        self.t_stop = t_stop
        
    def initialize(self, N_steps):
        self.N_steps = N_steps
        ts = np.linspace(0, self.t_stop, self.N_steps+1)
        correlations = np.empty(2*self.N_steps, dtype=complex)
        correlations[:self.N_steps+1] = self.alpha(ts)
        correlations[self.N_steps:] = np.conj(correlations[self.N_steps:0:-1])
        # compute spectral density by IFT and normalizing properly
        self.sqrtJ = np.sqrt(np.fft.fft(correlations))
    
    def sample_process(self):
        """
        Generates a realization of a complex gaussian process
        
        Returns
        -------
        np.ndarray:
            array of length N containing the complex stochastic process
        """
        eta = generate_white_noise(2*self.N_steps)
        return np.fft.ifft(np.fft.fft(eta) * self.sqrtJ)[0:self.N_steps]


class ColoredNoiseGenerator_SumApprox:
    """
    Class that generates a stochastic process with the given correlations
    using the method described in J. Chem. Phys. 144, 224105 (2016), 
    "An alternative realization of the exact non-Markovian stochastic Schrödinger equation"
    and in the supplementary material of Phys. Rev. A 105, L030202 (2022),
    "Non-Markovian stochastic Schrödinger equation: Matrix-product-state approach to the hierarchy of pure states"
    """
    
    def __init__(self, J, t_start, t_stop, N, w_cut, beta, use_alternative_expansion=False):
        """
        Constructs the generator

        Parameters
        ----------
        J: function of float returning float
            the spectral density
        t_start : float 
            starting time of the process
        t_stop : float 
            final time of the process
        N : int
            number of steps approximating the integral.
            higher N leads to more accurate result
        w_cut : float
            the cutoff frequency for approximating the integral.
            higher w_cut leads to more accurate result (if N
            is chosen sufficiently large)
        beta : float
            the inverse temperature
        use_alternative_expansion : bool
            wether to use the noise generation method necessary for 
            the alternative expansion of the BCF
        """
        dw = w_cut / N
        self.wj = (np.arange(N) + 0.5) * dw
        self.cj = np.sqrt(J(self.wj) * dw / np.pi)
        coths = 1 / np.tanh(self.wj*beta/2)
        if use_alternative_expansion:
            cschs = 1 / np.sinh(self.wj*beta/2)
            self.Aj_p = np.sqrt(coths + cschs)
            self.Aj_m = np.sqrt(coths - cschs)
        else:
            self.Aj_p = np.sqrt(coths/2+1/2)
            self.Aj_m = np.sqrt(coths/2-1/2)
        self.N = N
        self.t_start = t_start
        self.t_stop = t_stop
        self.use_alternative_expansion = use_alternative_expansion
        
    def initialize(self, N_steps):
        """
        Initializes the generator
        
        Parameters
        ----------
        N_steps : int
            length of the noise
        """
        self.N_steps = N_steps
        self.ts = np.linspace(self.t_start, self.t_stop, N_steps)
        
    def sample_process(self):
        """
        Generates a realization of a complex gaussian process
        
        Returns
        -------
        np.ndarray:
            array of length N containing the complex stochastic process
        """
        process = np.empty(self.N_steps, dtype=complex)
        if self.use_alternative_expansion:
            phi = np.random.random(self.N)
            for i in range(self.N_steps):
                arg = self.wj*self.ts[i] + 2*np.pi*phi
                Z = self.Aj_p * np.cos(arg) + 1.j * self.Aj_m * np.sin(arg)
                Z = np.sum(self.cj * Z)
                process[i] = Z
        else:
            phi_1 = np.random.random(self.N)
            phi_2 = np.random.random(self.N)
            for i in range(self.N_steps):
                arg_1 = 1.j * (self.wj*self.ts[i] + 2*np.pi*phi_1)
                arg_2 = 1.j * (-self.wj*self.ts[i] + 2*np.pi*phi_2)
                Z = self.Aj_m * np.exp(arg_1) + self.Aj_p * np.exp(arg_2)
                Z = np.sum(self.cj * Z)
                process[i] = Z
        return process
