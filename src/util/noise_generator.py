import numpy as np

"""
This file implements a complex stochastic process $z_t$ (colored noise) with the following properties:

- $\mathbb{E}\left[ z_t \right]=0,$
- $\mathbb{E}\left[ z_t z_s \right]=\mathbb{E}\left[ z_t^* z_s^* \right]=0$
- $\mathbb{E}\left[ z_t z_s^* \right]=\alpha(t-s)$

with the bath correlation function (BCF) \alpha(\tau).

Three implementations are given in this file:
1.) Implementation using a multivariate gaussian distribution
2.) Implementation using Fourier Filtering technique as also used in the original HOPS filter
3.) Custom implementation using Fourier Filtering technique. Produces similar results to 2.)

TODO: Maybe Switch to 3.) in all files using the noise generators!

the second method is recommended as it is much faster. For each method there is a class that has to be initialized first
and can then be used to sample stochastic processes.
"""

class ColoredNoiseGenerator_Gaussian:
    """
    Class that generates a stochastic process with the given correlations 
    using a multivariate gaussian.
    
    Attributes
    ----------
    N_steps : int:
        length of the discrete stochastic process
    cov_matrix : np.ndarray
        covariance matrix that is used to generate the noise.
        is of shape (N_steps*2, N_steps*2)
        
    Methods
    -------
    sample_process()
        samples one realization of the stochastic process
    """
    
    def __init__(self, ts, alpha):
        """
        Parameters
        ----------
        ts : np.ndarray
            time values. Should be created using np.linspace(t_start, t_stop, N_steps)
        alpha: function
            should take a float $\tau$ as input and compute the desired bath correlation function
        """
        self.N_steps = ts.size
        self.cov_matrix = np.empty((self.N_steps*2, self.N_steps*2))
        for i in range(self.N_steps):
            for j in range(self.N_steps):
                corr = alpha(ts[i]-ts[j])
                xx_cov = 0.5*np.real(corr)
                self.cov_matrix[2*i, 2*j] = xx_cov
                self.cov_matrix[2*i+1, 2*j+1] = xx_cov
                xy_cov = -0.5*np.imag(corr)
                self.cov_matrix[2*i, 2*j+1] = xy_cov
                self.cov_matrix[2*i+1, 2*j] = -xy_cov
    
    """
    Generates a realization of a complex gaussian process

    Returns
    -------
    np.ndarray :
        array of length N containing the complex stochastic process
    """
    def sample_process(self):
        res = np.random.multivariate_normal(mean=np.zeros(self.N_steps*2), cov=self.cov_matrix)
        x, y = res[0::2], res[1::2]
        return x + 1j*y
    
def generate_white_noise(N):
    """
    Helper function that generates white complex noise

    Parameters
    ----------
    N : int
        length of the noise
    
    Returns
    -------
    np.ndarray :
        array of length N containing the complex white noise
    """ 
    return np.sqrt(-np.log(np.random.rand(N))) * np.exp(2.j*np.pi*np.random.rand(N))
    
class ColoredNoiseGenerator_FourierFiltering:
    """
    Class that generates a stochastic process with the given correlations
    using the Fourier Filtering technique as described in the book
    "Noise in spatially extended systems", on pages 95 (and following) and 
    272 (and following). 
    This is similar to the implementation used in the original HOPS paper
    
    Attributes
    ----------
    N_steps : int:
        length of the discrete stochastic process
    sqrtJ : np.ndarray 
        the square root of the fourier transformed correlation function.
        The noise is generated by folding white noise with sqrtJ.
        
    Methods
    -------
    sample_process()
        samples one realization of the stochastic process
    """
    
    def __init__(self, N_steps, alpha, t_start, t_stop):
        """
        Initializes the generator by computing the values of the correlation function alpha
        at the discrete time steps and transforming it to frequency space
        ----------
        Parameters
        N_steps : int
            length of the noise
        alpha: function of float returning complex 
            correlation function
        t_start : float 
            starting time of the process
        t_stop : float 
            final time of the process
        """
        self.N_steps = N_steps
        assert(t_start==0)
        ts = np.linspace(0, t_stop, N_steps+1)
        correlations = np.empty(2*N_steps, dtype=complex)
        correlations[:N_steps+1] = alpha(ts)
        correlations[N_steps:] = np.conj(correlations[N_steps:0:-1])
        # compute spectral density by IFT and normalizing properly
        self.sqrtJ = np.sqrt(np.fft.fft(correlations))
        
    def sample_process(self):
        """
        Generates a realization of a complex gaussian process
        
        Returns
        -------
        np.ndarray:
            array of length N containing the complex stochastic process
        """
        eta = generate_white_noise(2*self.N_steps)
        return np.fft.ifft(np.fft.fft(eta) * self.sqrtJ)[0:self.N_steps]
    
class ColoredNoiseGenerator_FourierFiltering_custom:
    """
    Class that generates a stochastic process with the given correlations
    using the Fourier Filtering technique as described in the book
    "Noise in spatially extended systems", on pages 95 (and following) and 
    272 (and following). 
    This is similar to the implementation used in the original HOPS paper.
    This class is my owm implementation of the algorithm, but produces 
    similar redults.
    
    Attributes
    ----------
    N_steps : int:
        length of the discrete stochastic process
    sqrtJ : np.ndarray 
        the square root of the fourier transformed correlation function.
        The noise is generated by folding white noise with sqrtJ.
        
    Methods
    -------
    sample_process()
        samples one realization of the stochastic process
    """
    
    def __init__(self, N_steps, alpha, t_start, t_stop):
        """
        Initializes the generator by computing the values of the correlation function alpha
        at the discrete time steps and transforming it to frequency space
        ----------
        Parameters
        N_steps : int
            length of the noise
        alpha: function of float returning complex 
            correlation function
        t_start : float 
            starting time of the process
        t_stop : float 
            final time of the process
        """
        self.N_steps = N_steps
        assert(t_start==0)
        ts = np.linspace(-t_stop, t_stop, 2*N_steps-1)
        correlations = np.array(alpha(ts))
        # compute spectral density by IFT and normalizing properly
        self.sqrtJ = np.sqrt(np.fft.fft(correlations))
        
    def sample_process(self):
        """
        Generates a realization of a complex gaussian process
        
        Returns
        -------
        np.ndarray:
            array of length N containing the complex stochastic process
        """
        eta = generate_white_noise(2*self.N_steps-1)
        return np.fft.ifft(np.fft.fft(eta) * self.sqrtJ)[0:self.N_steps]